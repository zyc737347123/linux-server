# IO多路复用

## 0.0 概述

**I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Socket(I/O流)的状态来同时管理多个I/O流**. 发明它的原因，是尽量多的提高服务器的吞吐能力，

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，**这里的“复用”指的是复用同一个线程**，同一个进（线）程可以处理多个IO数据流，这样系统就不必创建进程/线程去处理多个IO流，也不必维护这些进程/线程，**需要的线程数减少，也就减少了内存开销和上下文切换的CPU开销**。

总的来说，从实际使用（非极限benchmark）上来说，线程池并不显著地比io多路复用慢，**多路复用的主要优势在于使用更少的内存等资源来支持更高的并发数**

## 1.0 select

## 2.0 epoll

## 3.0 IO多路复用历史

**select, poll, epoll 都是I/O多路复用的具体的实现，之所以有这三个鬼存在，其实是他们出现是有先后顺序的。** 

### 3.1 select

I/O多路复用这个概念被提出来以后， select是第一个实现 (1983 左右在BSD里面实现的)。select 被实现以后，很快就暴露出了很多问题。 
- select 会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。
-  select 如果任何一个sock(I/O stream)出现了数据，select 仅仅会返回，但是并不会告诉你是那个sock上有数据，于是你只能自己一个一个的找，10几个sock可能还好，要是几万的sock每次都找一遍，这个无谓的开销就颇有海天盛筵的豪气了。
-  select 只能监视1024个链接， 这个跟草榴没啥关系哦，linux 定义在头文件中的，参见FD_SETSIZE。
-  select 不是线程安全的，如果你把一个sock加入到select, 然后突然另外一个线程发现，尼玛，这个sock不用，要收回。对不起，这个select 不支持的，如果你丧心病狂的竟然关掉这个sock, select的标准行为是。。呃。。不可预测的， 这个可是写在文档中的哦.

“If a file descriptor being monitored by select() is closed in another thread, the result is unspecified”

### 3.2 poll

于是14年以后(1997年）一帮人又实现了poll, poll 修复了select的很多问题，比如 

- poll 去掉了1024个链接的限制，于是要多少链接呢， 主人你开心就好。
- poll 从设计上来说，不再修改传入数组，不过这个要看你的平台了，所以行走江湖，还是小心为妙。

其实拖14年那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求。

但是poll仍然不是线程安全的， 这就意味着，不管服务器有多强悍，你也只能在一个线程里面处理一组I/O流。你当然可以那多进程来配合了，不过这样你就有了多进程的各种问题。

### 3.3 epoll

于是5年以后, 在2002, 大神 Davide Libenzi 实现了epoll。epoll 可以说是I/O 多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题, 比如： 

- epoll 现在是线程安全的。 
- epoll 现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，你不用自己去找了。

## 参考文献

- [IO 多路复用是什么意思？](https://www.zhihu.com/question/32163005)
- [IO多路复用之select总结](https://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html)
- [IO多路复用和线程池哪个效率更高，更有优势？](https://www.zhihu.com/question/306267779)