# SQL基础

## 术语

1. `database`：数据库，保存有组织的数据的**容器**
2. `DBMS`：数据库管理系统，人们经常用数据库表示他们使用的数据库管理软件，这是不正确的。数据库是通过`DBMS`创建和操纵的容器
3. `schema`：模式，关于数据库和表的布局及特性的信息。用于描述数据库和表结构的元数据（meta data）
4. `primary key`：主键，一列（或一组列），其只能够唯一标识表中每一行；任意两行都不具有相同的主键值；每一行都必须具有一个主键值（主键值不允许NULL值）；主键列中的值不允许修改或更新；主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）
5. `clause`：子句，SQL由子句构成
6. `DESC`：降序，该关键字只应用到直接位于其前面的列名，如果想在多列上进行降序排序，必须对每一列指定`DESC`关键字
7. `operator`：逻辑操作符，用来联结或改变`WHERE`子句中子句的关键字
8. `wildcard`：通配符，用来匹配值的一部分的特殊字符，**通配符只能用于文本类型的字段**
9. `search pattern`：由字面值、通配符或两者组合构成的搜索条件
10. `%`：通配符之一，表示任何字符出现任意次数，不能匹配`NULL`
11. `_`：通配符之一，表示单个任意字符
12. `[]`：通配符之一，表示一个字符集合，测试发现MySQL不支持
13. `concatenate`：拼接，将值联结到一起（将一个值附加到另一个值）构成单个值
14. `cross join`：叉联结，笛卡尔积
15. `equijoin`：等值联结，inner join

## 注意点

1. 结束SQL语句：多条SQL语句必须以`;`分隔，单条语句不必须，最好加上
2. **SQL的大小写：SQL语句不区分大小写；建议SQL关键字大写，列名和表名小写**
3. SQL的空白格：SQL的所有空格都会被忽略；建议将长SQL语句分行书写
4. 在选择多个列时，用`,`分隔列名，最后一个列名后没有`,`
5. 使用通配符：按需要使用，检索不需要的列通常会降低性能
6. 检索未知列：可以使用通配符检索出未知列
7. 不能部分使用`DISTINCT`：`DISTINCT`关键字作用在所有选择的列，比如选择两个列，就是将两列的数据当做二元组，只有二元组不完全相同，就会被检索出来
8. LIMIT: `LIMIT 5`指示MySQL返回 不多于5行；`LIMIT 4 OFFSET 3`意为从行3开始取4行，就像`LIMIT 3, 4`
9. 并非所有的SQL实现都一样：非常基本的语句一般容易移植，但比较复杂的语句机不同了，当你针对某个问题寻找SQL解决方案时，一定要记住这点
10. 使用注释：大部分`DBMS`支持`--`单行注释，少数支持`#`的单行注释；`/**/`即为多行注释
11. 数据顺序：如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有任何意义
12. `ORDER BY`子句必须是最后一句，**测试后得到MySQL中`limit`可以放在`order by`后面**
13. 可以通过非选择列进行排序
14. 多列排序：多列排序时，会按照SQL语句中选择排序列的顺序进行优先排序
15. `SQL`过滤与应用过滤：数据可以在应用层过滤，但有几个缺点，影响应用性能，影响应用的伸缩性，多余的数据造成网络带宽的浪费
16. `!=`和`NULL`：测试发现MySQL，不会将`NULL`的行放入`!=`过滤出来的数据结果集
17. 检索NULL：用 `col is NULL`，`col = NULL`是无效的！！！！！
18. 检索非NULL：用`not col is NULL` ！！！！！
19. 任何时候在使用具有逻辑操作符的`where`子句中，都应该使用`()`明确的分组操作符，不要过分依赖默认求值顺序
20. 测试计算：`SELECT`语句省略`FROM`子句后就是简单的访问和处理表达式
21. 必须的顺序：`WHERE` -> `GROUP BY` -> `ORDER BY`
22. 分组：分组类似把表的数据按某些列拆分成不同的小表，一般配合聚集函数使用
23. `WHERE`和`HAVING`：最大区别在于`where`在数据分组前过滤，`having`在数据分组后过滤
24. `HAVING`一般配合`GROUP BY`使用
25. 日期格式：总是使用`yyyy-mm-dd`
26. 比较日期：使用Date(col)是稳妥做法
27. 想按月找时间：使用`Year() and Month()`
28. 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空 值（NULL）还是非空值
29. 使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值
30. 利用标准的算术操作符， 所有聚集函数都可用来执行多个列上的计算
31. 使用聚集函数时： 只包含不同的值，指定DISTINCT参数
32. DISTINCT 不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT）， 否则会产生错误
33. 子查询的性能比联结差（待验证）
34. 联结的表越多，性能下降越厉害
35. 自联结：利用表别名，在查询中一张表自身联结自身，不用表别名会有二义性问题
36. MySQL只支持left join和right join
37. 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单
38. UNION中的每个查询必须包含相同的列、表达式或聚集函数
39. 每个查询的列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以 隐含地转换的类型
40. 如果确实需要每个条件的匹配行全 部出现（包括重复行），则必须使用UNION ALL而不是WHERE
41. 全文本搜索：更好的性能，明确控制，智能化结果
42. 不要在导入数据时使用FULLTEXT
43. 传递给 Match() 的值必须与 FULLTEXT()定义中的相同。如果指定多个列，则必须列出它 们（而且次序正确）
44. 全文本搜索的一 个重要部分就是对结果排序。具有较高等级的行先返回
45. 全文本搜索以单词or短语为搜索单位
46. 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文 本搜索结果
47. 一般不要使用没有明确给出列的列表的 INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化
48. 如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）
49. 创建表时NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL
50. NULL值是没有值， 它不是空串''
51. MySQL不允许使用函 数作为默认值，它只支持常量
52. 外键不能跨引擎
53. 理想状态下，当表中存储数据以后，该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动
54. 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）
55. 视图：如果你用多个联结 和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应 该进行测试
56. ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖
57. 视图不能索引，也不能有关联的触发器或默认值
58. 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句
59. 存储过程：SQL写的脚本
60. 所有MySQL变量都必须以@开始
61. 游标：游标主要用于交互式应用，MySQL游标只能用于 存储过程（和函数），像个指针，在存储过程里用这个指针对每一行数据做处理
62. 如果你不明确关闭游标，MySQL将会在到达END语 句时自动关闭它
63. 如果处理过程需要重复使用一个记录集，那么创建一次游标而重复使用若干次，比重复查询数据库要快的多
64. 触发器：是MySQL响应以下任意语句而 自动执行的一条MySQL语句（update，insert，delete）；只有表才可以有触发器
65. 触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后）
66. 如果你使用的是mysql命令行实用程序，默认的MySQL语句分隔符为;（正如你已经在迄今为止所使用 的MySQL语句中所看到的那样）。mysql命令行实用程序也使 用;作为语句分隔符。如果命令行实用程序要解释存储过程自 身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误
67. 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透 明地进行，与客户机应用无关
68. autocommit标志是针对每个连接而不是服务器的

