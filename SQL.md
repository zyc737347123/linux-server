# SQL基础

## 术语

1. `database`：数据库，保存有组织的数据的**容器**
2. `DBMS`：数据库管理系统，人们经常用数据库表示他们使用的数据库管理软件，这是不正确的。数据库是通过`DBMS`创建和操纵的容器
3. `schema`：模式，关于数据库和表的布局及特性的信息。用于描述数据库和表结构的元数据（meta data）
4. `primary key`：主键，一列（或一组列），其只能够唯一标识表中每一行；任意两行都不具有相同的主键值；每一行都必须具有一个主键值（主键值不允许NULL值）；主键列中的值不允许修改或更新；主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）
5. `clause`：子句，SQL由子句构成
6. `DESC`：降序，该关键字只应用到直接位于其前面的列名，如果想在多列上进行降序排序，必须对每一列指定`DESC`关键字
7. `operator`：逻辑操作符，用来联结或改变`WHERE`子句中子句的关键字
8. `wildcard`：通配符，用来匹配值的一部分的特殊字符，**通配符只能用于文本类型的字段**
9. `search pattern`：由字面值、通配符或两者组合构成的搜索条件
10. `%`：通配符之一，表示任何字符出现任意次数，不能匹配`NULL`
11. `_`：通配符之一，表示单个任意字符
12. `[]`：通配符之一，表示一个字符集合，测试发现MySQL不支持
13. `concatenate`：拼接，将值联结到一起（将一个值附加到另一个值）构成单个值
14. `cross join`：叉联结，笛卡尔积
15. `equijoin`：等值联结，inner join

## 注意点

1. 结束SQL语句：多条SQL语句必须以`;`分隔，单条语句不必须，最好加上
2. **SQL的大小写：SQL语句不区分大小写；建议SQL关键字大写，列名和表名小写**
3. SQL的空白格：SQL的所有空格都会被忽略；建议将长SQL语句分行书写
4. 在选择多个列时，用`,`分隔列名，最后一个列名后没有`,`
5. 使用通配符：按需要使用，检索不需要的列通常会降低性能
6. 检索未知列：可以使用通配符检索出未知列
7. 不能部分使用`DISTINCT`：`DISTINCT`关键字作用在所有选择的列，比如选择两个列，就是将两列的数据当做二元组，只有二元组不完全相同，就会被检索出来
8. LIMIT: `LIMIT 5`指示MySQL返回 不多于5行；`LIMIT 4 OFFSET 3`意为从行3开始取4行，就像`LIMIT 3, 4`
9. 并非所有的SQL实现都一样：非常基本的语句一般容易移植，但比较复杂的语句机不同了，当你针对某个问题寻找SQL解决方案时，一定要记住这点
10. 使用注释：大部分`DBMS`支持`--`单行注释，少数支持`#`的单行注释；`/**/`即为多行注释
11. 数据顺序：如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有任何意义
12. `ORDER BY`子句必须是最后一句，**测试后得到MySQL中`limit`可以放在`order by`后面**
13. 可以通过非选择列进行排序
14. 多列排序：多列排序时，会按照SQL语句中选择排序列的顺序进行优先排序
15. `SQL`过滤与应用过滤：数据可以在应用层过滤，但有几个缺点，影响应用性能，影响应用的伸缩性，多余的数据造成网络带宽的浪费
16. `!=`和`NULL`：测试发现MySQL，不会将`NULL`的行放入`!=`过滤出来的数据结果集
17. 检索NULL：用 `col is NULL`，`col = NULL`是无效的！！！！！
18. 检索非NULL：用`not col is NULL` ！！！！！
19. 任何时候在使用具有逻辑操作符的`where`子句中，都应该使用`()`明确的分组操作符，不要过分依赖默认求值顺序
20. 测试计算：`SELECT`语句省略`FROM`子句后就是简单的访问和处理表达式
21. 必须的顺序：`WHERE` -> `GROUP BY` -> `ORDER BY`
22. 分组：分组类似把表的数据按某些列拆分成不同的小表，一般配合聚集函数使用
23. `WHERE`和`HAVING`：最大区别在于`where`在数据分组前过滤，`having`在数据分组后过滤
24. `HAVING`一般配合`GROUP BY`使用
25. 日期格式：总是使用`yyyy-mm-dd`
26. 比较日期：使用Date(col)是稳妥做法
27. 想按月找时间：使用`Year() and Month()`
28. 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空 值（NULL）还是非空值
29. 使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值
30. 利用标准的算术操作符， 所有聚集函数都可用来执行多个列上的计算
31. 使用聚集函数时： 只包含不同的值，指定DISTINCT参数
32. DISTINCT 不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT）， 否则会产生错误
33. 子查询的性能比联结差（待验证）
34. 联结的表越多，性能下降越厉害
35. 自联结：利用表别名，在查询中一张表自身联结自身，不用表别名会有二义性问题
36. MySQL只支持left join和right join
37. 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单

