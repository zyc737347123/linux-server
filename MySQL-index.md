# MySQL索引

## 1. 索引模型
索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多

- 哈希表：**基于数组和链表，链表用于解决哈希值冲突。哈希表适用于只有等值查询的场景**，比如 Memcached 及其他一些 NoSQL 引擎。
- 有序数组：**有序数组在等值查询和范围查询场景中的性能都非常优秀（都可以用二分法快速查找），但是更新数据成本非常高**，所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据
- 搜索树：为了更好利用局部性原理，采用N叉平衡树，常见的有B-树，B+树，MySQL的innoDB引擎使用B+树

## 2. 索引类型

- 主键索引：聚簇索引（clustered index），对于聚集索引，**叶子结点即存储了真实的数据行**，不再有另外单独的数据页；**在一张表上只能创建一个聚集索引**，因为真实数据的物理顺序只可能是一种。如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加的表的末尾位置
- 非主键索引：**非主键索引的叶子节点内容是主键的值**。在 InnoDB 里，非主键索引也被称为二级索引（secondary index），普通索引工作原理是，根据索引字段在普通索引中找到对应的主键，再根据主键在主键索引中找到完整的行数据；基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询
- 覆盖索引：复合索引or多字段索引查询，当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中；比如根据字段A、B建立了复合索引，在根据字段A找到索引结果时，可以找到对应的字段B，就可以不用再根据主键去查找主键索引，节约了一次扫描；**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**
- 唯一索引：不允许具有索引值相同的行，从而禁止重复的索引或键值；唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复；主键索引是特殊的唯一索引

## 3. 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。

如果插入数据的主键排序是在当前主键排序中间，就需要挪动节点中的已有数据，如果对应的节点（数据页）已经满了，根据 B+ 树的算法，这时候需要申请一个新的节点（数据页），然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。[B+树数据插入图解](https://www.cnblogs.com/nullzx/p/8729425.html)

如果插入数据主键排序是最末端的，则只需要在已有节点的剩余空间插入新数据，不会涉及数据挪动和分页。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%

### 3.1 自增主键与索引

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`

插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值

也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂

除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择