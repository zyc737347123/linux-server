# MySQL索引

**在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标**

## 1. 索引模型
索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多

- 哈希表：**基于数组和链表，链表用于解决哈希值冲突。哈希表适用于只有等值查询的场景**，比如 `Memcached `及其他一些`NoSQL`引擎。
- 有序数组：**有序数组在等值查询和范围查询场景中的性能都非常优秀（都可以用二分法快速查找），但是更新数据成本非常高**，所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据
- 搜索树：为了更好利用局部性原理，采用N叉平衡树，常见的有B-树，B+树，`MySQL`的`innoDB`引擎使用B+树

## 2. 索引类型

- 主键索引：聚簇索引（clustered index），对于聚集索引，**叶子结点即存储了真实的数据行**，不再有另外单独的数据页；**在一张表上只能创建一个聚集索引**，因为真实数据的物理顺序只可能是一种。如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加的表的末尾位置
- 非主键索引：**非主键索引的叶子节点内容是主键的值**。在`InnoDB`里，非主键索引也被称为二级索引（secondary index），普通索引工作原理是，根据索引字段在普通索引中找到对应的主键，再根据主键在主键索引中找到完整的行数据；基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询
- 覆盖索引：复合索引or多字段索引查询，当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中；比如根据字段A、B建立了复合索引，在根据字段A找到索引结果时，可以找到对应的字段B，就可以不用再根据主键去查找主键索引，节约了一次扫描；**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**
- 唯一索引：不允许具有索引值相同的行，从而禁止重复的索引或键值；**唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复**；主键索引是特殊的唯一索引

## 3. 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。

如果插入数据的主键排序是在当前主键排序中间，就需要挪动节点中的已有数据，如果对应的节点（数据页）已经满了，根据 B+ 树的算法，这时候需要申请一个新的节点（数据页），然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。[B+树数据插入图解](https://www.cnblogs.com/nullzx/p/8729425.html)

如果插入数据主键排序是最末端的，则只需要在已有节点的剩余空间插入新数据，不会涉及数据挪动和分页。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%

### 3.1 自增主键与索引

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`

插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值

也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂

除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（`bigint`）则是 8 个字节

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择

## 4. 最左前缀原则与联合索引

如果查询的时候查询条件精确匹配**联合索引**的左边连续一列或几列，则此列就可以被用到。不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索

**最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符**

### 4.1 在建立联合索引的时候，如何安排索引内的字段顺序

**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的**

### 4.2 为什么会有最左前缀原则

`mysql`创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。

所以：**第一个name字段是绝对有序的，而第二字段就是无序的了**。所以通常情况下，**直接使用第二个cid字段进行条件判断是用不到索引的**，当然，可能会出现上面的使用index类型的索引。这就是所谓的`mysql`为什么要强调最左前缀原则的原因

PS：`index`类型的查询表示是`mysql`会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，`mysql`都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，`mysql`会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。虽然还是查询了所有数据，但是和查询全表完整数据相比，查询所有索引数据的磁盘读取次数还是会少，因为索引存的数据是完整数据的一部分，所以要读的磁盘次数会少。

### 4.3 注意事项

1. 最左前缀匹配原则，非常重要的原则，`mysql`会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2. `=`和`in`可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，`mysql`的查询优化器会帮你优化成索引可以识别的形式

## 5. 索引下推

对于不符合最左前缀的检索，可以采用索引下推

`MySQL 5.6`引入的索引下推优化（index condition pushdown)， **可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录**，减少**回表**次数**（回表：回到主键索引树搜索的过程）**

不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给`MySQL`服务器，服务器然后判断数据是否符合条件。

当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，`MySQL`服务器**将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合`MySQL`服务器传递的条件**，只有当索引符合条件时才会将数据检索出来返回给`MySQL`服务器。

索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少`MySQL`服务器从存储引擎接收数据的次数。

**由于需要存储引擎将索引中的数据与条件进行判断，所以这个技术是基于存储引擎的，只有特定引擎可以使用。并且判断条件需要是在存储引擎这个层面可以进行的操作才可以**，比如调用存储过程的条件就不可以，因为存储引擎没有调用存储过程的能力。

## 6. 杂项

- 重建索引：索引可能因为数据删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引会更紧凑、更省空间
- 重建主键：不论是删除主键还是创建主键，都会将整个表重建；不应该使用
- 索引的应用：`order by`也可以利用索引的排序性质，减少数据的排序开销

## 参考文献
- 深入浅出索引
- [数据库进阶系列之一：漫谈数据库索引](https://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html)
- [谈谈唯一约束和唯一索引](https://zhuanlan.zhihu.com/p/35019649)